title: CVE-2012-0158漏洞分析
date: 2015-09-14 20:21:02
tags: 缓冲区溢出
---

CVE-2012-0158是典型的缓冲区溢出漏洞，在MSCOMCTL.OCX空间空间，发生溢出
<!--more-->
本文参考[CVE-2012-0158 MSCOMCTL控件漏洞分析](http://bbs.pediy.com/showthread.php?t=149957)，这篇文章分析的很详细，本文菜鸟一枚，记录分析过程，与大家分享，希望共同进步。

#实验环境
- Windows xp sp3
- word 2007 12.0.4518.1014
- Windbg
在调试漏洞过程中，尽量使用Windbg，执行效率高，还是记录执行路径，并且有强大的脚本做后盾。

#溢出函数
MSCOMCTL!DllGetClassObject+0xb413两次调用MSCOMCTL!DllGetClassObject+0xb1b9，在第二次调用MSCOMCTL!DllGetClassObject+0xb1b9时，溢出。
如果大家想跟进漏洞的成因，可以看[CVE-2012-0158 MSCOMCTL控件漏洞分析](http://bbs.pediy.com/showthread.php?t=149957)
但是我建议大家先自己分析一篇漏洞，在看成因

#分析过程
##1、断点
用Windbg附加WinWord进程，即File --> open Executable --> WinWord.exe
在MSCOMCTL!DllGetDocumentation+0xcec处下断点
如图：
![](http://ww2.sinaimg.cn/large/005CA6ZCgw1ew2xnhjojwj30fh00zmx2.jpg)

##2、g 执行到断点处

![](http://ww1.sinaimg.cn/large/005CA6ZCgw1ew2xqsfy1bj30fm02674e.jpg)

此时，并没有执行到断点处，但Windbg输入命令行处灰显，debuggee is runnning...，表明Windbg在等待用户输入，我们可以看到Word界面了

##3、打开包含shellcode的doc，即may.doc

![](http://ww1.sinaimg.cn/large/005CA6ZCgw1ew2xtyisxdj30cz0djtac.jpg)
word处于忙碌状态，此后就可以不用管word了，专注于Windbg吧，回到Windbg中去

##4、g 执行到断点处 

继续g，执行到断点处
![](http://ww2.sinaimg.cn/large/005CA6ZCgw1ew2y09hnqdj30ls0gswjy.jpg)
前面说过，漏洞在MSCOMCTL!DllGetClassObject+0xb413函数内，进入此函数

##5、F8 进入MSCOMCTL!DllGetClassObject+0xb413

F8进入此函数
以下是该函数的汇编代码：
![](http://ww3.sinaimg.cn/large/005CA6ZCgw1ew2y2pigovj30m10ho444.jpg)
![](http://ww4.sinaimg.cn/large/005CA6ZCgw1ew2y3n0qcwj30iu03p0tg.jpg)

###第一次调用MSCOMCTL!DllGetClassObject+0xb1b9时，参数如下
![](http://ww4.sinaimg.cn/large/005CA6ZCgw1ew3f1mpmmuj30ih0300th.jpg)

###第二次调用MSCOMCTL!DllGetClassObject+0xb1b9时，参数如下
![](http://ww2.sinaimg.cn/large/005CA6ZCgw1ew3f1zxaklj30ih033gm9.jpg)

根据后面对MSCOMCTL!DllGetClassObject+0xb1b9的分析可知，将第二个参数指向的内存区域内的字符串，拷贝到第一个参数指向的内存区域中，长度为第三个参数

在第二次调用MSCOMCTL!DllGetClassObject+0xb1b9的时候发生溢出，我们进入此函数

##6、F8进入MSCOMCTL!DllGetClassObject+0xb1b9

![](http://ww4.sinaimg.cn/large/005CA6ZCgw1ew3cpj0zq1j30lx0hjwjc.jpg)
![](http://ww4.sinaimg.cn/large/005CA6ZCgw1ew3cq09hcdj30lx08f40d.jpg)

##7、一路F10执行到  275a24fe  
即图片标红处，关于rep movs，请看[rep movs指令](http://huirong.github.io/2015/09/14/rep-movs/)
查看ECX，EDI，ESI寄存器的值：

![](http://ww3.sinaimg.cn/large/005CA6ZCgw1ew3d5nw9fxj30i704mq49.jpg)

将esi指向的字符串拷贝到edi指向的地址，长度ecx = 000020a0 dword = 00008282B，即shellcode的长度

ESI=00202618，在内存中查看此内存段的值：

![](http://ww1.sinaimg.cn/large/005CA6ZCgw1ew3cs0cw5wj30a00bp41f.jpg)

方框内为shellcode

##8、F10 执行到275a2500
 即方框的下一步
 rep movs dword ptr es:[edi],dword ptr [esi]执行之前，EDI=0x00122490
 执行完rep movs dword ptr es:[edi],dword ptr [esi]，查看0x00122490处的值

 ![](http://ww2.sinaimg.cn/large/005CA6ZCgw1ew3duooerxj309y0cjjuk.jpg)

shellcode已经成功拷贝到栈中

##9、一路F10，直到MSCOMCTL!DllGetClassObject+0xb413返回
![](http://ww3.sinaimg.cn/large/005CA6ZCgw1ew3ezo9iwzj30sv0hq49g.jpg)

**返回之后跳转到0x001224a8，在此过程中成功调用计算器**

![](http://ww2.sinaimg.cn/large/005CA6ZCgw1ew3cuuvatej30fe082wg4.jpg)

![](http://ww1.sinaimg.cn/large/005CA6ZCgw1ew3cuhid7nj310r08etbo.jpg)

#总结
MSCOMCTL!DllGetClassObject+0x3ab15(275c8b4e)（A 函数）仅仅开辟了0x14h 大小的栈空间，里边两次调用了函数MSCOMCTL!DllGetClassObject+0x3a8bb ( B 函数)。第一次往A 函数的栈帧里边写入了0xc 大小的字节，第二次调用前检查了大小，本该是长度应该小于等于8 才copy 数据，<font color="red">结果程序员的粗心大意写成了大于等于8</font>。直接导致第二次调用写入了0x8282 大小的数据，其后果是很严重的——破坏掉了A 函数的栈帧，导致A 函数无法正确返回。此处返回地址被精心覆盖成0x7ffa4512，直接导致了恶意代码的执行。

#参考文献
[CVE-2012-0158 MSCOMCTL控件漏洞分析](http://bbs.pediy.com/showthread.php?t=149957)
